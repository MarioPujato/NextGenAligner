#!/usr/bin/env perl
use strict;
use warnings;
use Cwd;
use Getopt::Std;
use Parallel::ForkManager;

my $progName = $0;
$progName    =~ s/^.*\///;
my $version  = '1.5.1';
my $created  = '011017';
my $modified = '012320';
#-------------------------------------------------------------------------------
# Change log
#-------------------------------------------------------------------------------
# 030920 - 1.5.1: Bugfix. HISAT2 and BOWTIE2 incapable of renaming unmapped files
# 012320 - 1.5.0: Replaced samtools sort and picard markduplicates with sambamba
# 010220 - 1.4.5: Fixed removal of intermediate FASTQ files
#-------------------------------------------------------------------------------

my %options;
# EHKLNPQRSTUVWYZ
# abcdfhnmopqrstxyz
# available: egklnvw
getopts('I:F:B:C:X:O:p:achimqrstuxy', \%options);

# Display help
if( $options{'h'} or ! %options ){
	MESSAGES::die_with_usage( $progName, $version, $created, $modified );
}

if( $options{'x'} or $options{'y'} ){
	# Print pipeline scheme
	MESSAGES::print_scheme( $progName, $version ) if $options{'x'};
	# Print example config file
	MESSAGES::print_configuration_file( $progName, $version ) if $options{'y'};
	exit;
}
# Create output directory (if specified)
$options{'O'} = $options{'O'} || '.';
my $outDir    = $options{'O'};
my $logsDir   = "$outDir/NGA_logs";
$options{'LOGS_DIR'} = $logsDir;
`mkdir -p $logsDir` if $outDir;

# Open pipeline LOG file
my $pipelineLog = "$logsDir/general.log";
open( my $PLOG, ">$pipelineLog" ) or
	die "ERROR: Could not create log file $pipelineLog\n";
$options{'PLOG'} = $PLOG; # Save pipeline log filehandle

# Add version to options
$options{'VERSION'} = $version;

# Configure the program
my $Config = new CONFIGURATION(
 	options => \%options,
	outDir  => $outDir,
);

#-------------------------------------------------------------------------------
# MAIN
#||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||

my $dateStart = `date`; chomp $dateStart;
my $timeStart = time;
print $PLOG "\nStart time: $dateStart\n";
print $PLOG "--------------------------------------------------------------------------------\n";

# Inputs:
# I SRA_ID
# S SRA
# F FASTQ_read1:2 FASTQ_read2
# A BAM

# Get input type together with correct files
#-------------------------------------------------------------------------------
my $iType  = $Config->get_value('iType');
my @inputs = split( ',', $Config->get_value($iType) );
my $iNum   = scalar @inputs;

#===============================================================================
# CONCATENATE FASTQ FILES
#===============================================================================
if( $options{'i'} and $iNum > 1 ){
	my $outDir  = $Config->get_value('O');
	print $PLOG  "Concatenation of input files requested\n";
	print STDERR "Concatenation of input files requested\n";

	# Download multiple SRA files and converte them to FASTQ
	if( $Config->get_value('I') ){
		my @fastqFiles;

		for( my $i = 0; $i < $iNum; $i++ ){
			my $input = $inputs[$i];
			print $PLOG  "  > Downloading $input\n";
			print STDERR "  > Downloading $input\n";

			$input = process_sra( $input, $Config );
			push( @fastqFiles, $input );
		}
		@inputs = @fastqFiles;
		$iNum   = scalar @inputs;
		$Config->set_value( 'F', \@inputs );

		print $PLOG  "\e[0;32m[ DONE ]\e[0m\n";
		print STDERR "\e[0;32m[ DONE ]\e[0m\n";
	}

	# Merged/Concatenate multiple FASTQ files into one
	if( $Config->get_value('F') ){
		print $PLOG  "  > Concatenating FASTQ files\n";
		print STDERR "  > Concatenating FASTQ files\n";

		# Extract basename
		my $baseName = $inputs[0];
		$baseName    =~ s/^.*\///;
		$baseName    =~ s/\..*$//;

		# Default names for the merged FASTQ files
		my $mergedFastq1 = "$outDir/$baseName\_1.fastq.gz";
		my $mergedFastq2 = "$outDir/$baseName\_2.fastq.gz";

		# Make sure the merged files do not exist by removing any existing ones
		`rm -f $mergedFastq1 $mergedFastq2 2> /dev/null`;

		# Concatenate FASTQ files
		for( my $i = 0; $i < $iNum; $i++ ){
			my( $input1, $input2 ) = split( ':', $inputs[$i] );
			print $PLOG  "    > Read 1: $input1\n";
			print STDERR "    > Read 1: $input1\n";

			if( !-s $input1 ){
				print $PLOG "ERROR: File $input1 does not exist or it's empty\n";
				die "ERROR: File $input1 does not exist or it's empty\n";
			}
			my $cat = 'cat';
			$cat    = 'zcat' if $input1 =~ /gz$/;
			print $PLOG "    COMMAND: $cat $input1 | gzip -c >> $mergedFastq1\n";
			`$cat $input1 | gzip -c >> $mergedFastq1`;

			if( $input2 ){
				if( !-s $input2 ){
					print $PLOG "ERROR: File $input2 does not exist or it's empty\n";
					die "ERROR: File $input2 does not exist or it's empty\n";
				}
				print $PLOG  "    > Read 2: $input2\n";
				print STDERR "    > Read 2: $input2\n";
				$cat = 'cat';
				$cat = 'zcat' if $input2 =~ /gz$/;
				print $PLOG "    COMMAND: $cat $input2 | gzip -c >> $mergedFastq2\n";
				`$cat $input2 | gzip -c >> $mergedFastq2`;

				$Config->set_value( 'F', "$mergedFastq1:$mergedFastq2" );
			}
			else{
				$Config->set_value( 'F', $mergedFastq1 );
			}

			# Save FASTQ files (no longer in use)
			if( ! $Config->get_value('SAVE_FASTQ') ){
				`rm -f $input1 $input2 2> /dev/null`;
			}
		}
		print STDERR "\e[0;32m[ DONE ]\e[0m\n";
	}
	$Config->set_value( 'I', 0 );
	$iType  = 'F';
	@inputs = split( ',', $Config->get_value($iType) );
	$iNum   = scalar @inputs;

	# Continue if BAM file or quality control on FASTQ file is requested
	if( ! $Config->get_value('a') or ! $Config->get_value('q') ){
		my $timeEnd = time;
		my $elapsed = sprintf( "%.2f", ( $timeEnd - $timeStart ) / 60 );
		print $PLOG "\n--------------------------------------------------------------------------------\n";
		print $PLOG "\nEnd time: $timeEnd\n";
		print $PLOG "\n--------------------------------------------------------------------------------\n";
		print $PLOG "Total elapsed time: $elapsed\n";
		exit;
	}
}

#===============================================================================
# NGS PIPELINE
#===============================================================================
for( my $i = 1; $i <= $iNum; $i++ ){
	my $input  = $inputs[$i-1];
	print $PLOG  "\n>> Processing input \'$iType\' ($i/$iNum)\n";
	print STDERR "\n>> Processing input \'$iType\' ($i/$iNum)\n";

	#-------------------------------------------------------------------------------
	# Create FASTQ files from SRA files
	#-------------------------------------------------------------------------------
	$Config->set_value( 'QC', 0 ); # Quality control on raw reads flag

	if( $Config->get_value('I') ){
		print $PLOG  "Processing SRA\n  > $input\n";
		print STDERR "Processing SRA\n  > $input\n";

		$input = process_sra( $input, $Config );

		print $PLOG  "\e[0;32m[ DONE ]\e[0m\n";
		print STDERR "\e[0;32m[ DONE ]\e[0m\n";
	}

	#-------------------------------------------------------------------------------
	# Align reads to genome
	#-------------------------------------------------------------------------------
	$Config->set_value( 'DP', 0 ); # Remove duplicate reads flag

	if( $Config->get_value('F') ){
		print $PLOG  "Processing FASTQ file\n";
		print STDERR "Processing FASTQ file\n";

		my $Fastq = load_fastq_file( $input, $Config );
		$input    = process_fastq_file( $Fastq, $Config );

		print $PLOG  "\e[0;32m[ DONE ]\e[0m\n";
		print STDERR "\e[0;32m[ DONE ]\e[0m\n";
	}
	# Continue if BAM files were requested
	next unless(
		$Config->get_value('B') or
		$Config->get_value('c')
	);

	#-------------------------------------------------------------------------------
	# Take BAM file as input
	#-------------------------------------------------------------------------------
	$Config->set_value( 'SP', 0 ); # Split BAM by chromosomes flag

	if( $Config->get_value('B') ){
		# Index and split BAM file by chromosomes
		print $PLOG  "Processing BAM file\n  > $input\n";
		print STDERR "Processing BAM file\n  > $input\n";

		my $Alignment = process_bam_file( $input, $Config );

		# Save BAM file (no longer in use)
		if( !$Config->get_value('SAVE_BAM') ){
			my $input = $Alignment->get_file;
			`rm -f $input 2> /dev/null`;
		}

		# Remove per chromosome BAM files (no longer used)
		`rm -f $outDir/chr*.bam $outDir/*.bai 2> /dev/null`;
		# Remove per chromosome BED files (no longer used)
		`rm -f $outDir/chr*.bed 2> /dev/null`;
		# Remove intermediate FASTQ files (no longer used)
		`rm -f $outDir/*q.gz 2> /dev/null`;

		print $PLOG  "\e[0;32m[ DONE ]\e[0m\n";
		print STDERR "\e[0;32m[ DONE ]\e[0m\n";
	}
}
my $dateEnd = `date`; chomp $dateEnd;
my $timeEnd = time;
my $elapsed = sprintf( "%.2fm", ( $timeEnd - $timeStart ) / 60 );
print $PLOG "End time: $dateEnd\n";
print $PLOG "\n--------------------------------------------------------------------------------\n";
print $PLOG "Total elapsed time: $elapsed\n";

exit;



#||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||

# SUBROUTINES
#-------------------------------------------------------------------------------
sub process_sra
{
	my $input  = shift;
	my $Config = shift;
	my $PLOG   = $Config->get_value('PLOG');

	my $Fastq = new FASTQ(
		config => $Config,
	);
	$Fastq->generate( $input );

	my $fastq1 = $Fastq->get_file1;
	my $fastq2 = $Fastq->get_file2;

	if( $fastq2 ){
		$input = "$fastq1:$fastq2";
	}
	else{
		$input = $fastq1;
	}
	$Config->set_value( 'F', $input );

	return $input;
}

sub load_fastq_file
{
	my $input  = shift;
	my $Config = shift;
	my $PLOG   = $Config->get_value('PLOG');

	my @jFiles = split( ':', $input );
	my $jFile1 = $jFiles[0];
	my $jFile2 = $jFiles[1];

	print $PLOG  "  > $jFile1\n";
	print $PLOG  "  > $jFile2\n" if $jFile2;
	print STDERR "  > $jFile1\n";
	print STDERR "  > $jFile2\n" if $jFile2;

	my $Fastq = new FASTQ(
		config => $Config,
	);
	$Fastq->set_file1( $jFile1 );
	$Fastq->set_file2( $jFile2 ) if $jFile2;

	return $Fastq;
}

sub process_fastq_file
{
	my $Fastq  = shift;
	my $Config = shift;
	my $PLOG   = $Config->get_value('PLOG');

	# Quality control on raw reads
	if( $Config->get_value('q') ){
		my $qcLogs = $Fastq->quality_control;

		if( $Config->get_value('m') ){
			print $PLOG  "  Skip trimming of sequences\n";
			print STDERR "  Skip trimming of sequences\n";
		}
		else{
			$Fastq->trim_adapters( $qcLogs );
		}
	}

	# Exit if alignment was not requested
	return 0 if ! $Config->get_value('a');

	# Align reads to genome
	my $Alignment = new ALIGNMENT(
		fastq  => $Fastq,
		config => $Config,
	);
	$Alignment->align_to_genome;

	# Remove duplicate reads
	if( !$Config->get_value('r') ){
		$Alignment->remove_duplicates;
		$Config->set_value( 'DP', 1 );
	}

	# Sort BAM file
	$Alignment->sort_bam;

	# Save FASTQ files (no longer in use)
	if( !$Config->get_value('SAVE_FASTQ') ){
		my $fastq1 = $Fastq->get_file1;
		my $fastq2 = $Fastq->get_file2;
		`rm -f $fastq1 2> /dev/null`;
		`rm -f $fastq2 2> /dev/null` if $fastq2;
	}
	my $input = $Alignment->get_file;
	$Config->set_value( 'B',  $input );

	return $input;
}

sub process_bam_file
{
	my $input  = shift;
	my $Config = shift;
	my $PLOG   = $Config->get_value('PLOG');
	my $outDir = $Config->get_value('O');

	my $Alignment = new ALIGNMENT(
		file   => $input,
		config => $Config,
	);

	# Remove duplicate reads
	unless( $Config->get_value('r') or $Config->get_value('DP') ){
		$Alignment->remove_duplicates;
	}

	# Sort BAM file
	$Alignment->sort_bam;

	# Stop if not calling peaks (only BAM file requested)
	return $Alignment if ! $Config->get_value('c');

	# Call peaks with MACS2
	print $PLOG  "Call peaks from BAM file\n  > $input\n";
	print STDERR "Call peaks from BAM file\n  > $input\n";

	my $Peaks = new PEAKS(
		bamFile => $Alignment->get_file,
		config  => $Config,
	);
	my $peakTypes = $Peaks->get_peak_types;
	my @sorted    = sort{ $a cmp $b } keys %$peakTypes;

	for my $type ( @sorted ){
		$Peaks->call_peaks( $type );
	}

	return $Alignment;
}

#-------------------------------------------------------------------------------
package MESSAGES;
use warnings;
use strict;

sub die_with_usage
{
	my $progName = shift;
	my $version  = shift;
	my $created  = shift;
	my $modified = shift;
	my $examples = get_examples( $progName );

	die"
\e[0;33m================================================================================\e[0m

\e[1;31m$progName\e[0m
\e[0;33mNext-Generation sequencing alignment pipeline\e[0m

\e[0;33mVersion:    $version\e[0m
\e[0;33mCreated:    $created\e[0m
\e[0;33mModified:   $modified\e[0m
\e[0;33mWritten by: Mario Pujato

\e[0;33m================================================================================\e[0m



\e[0;31mUSAGE: $progName [options] <arguments>\e[0m

  [options]

    ARGUMENTS
      -O  Name of output folder
      -C  Configuration file (a sample file can be generated using option -y)
      -I  SRA IDs. Comma-separated list
            Based on these IDs, SRA files will be downloaded from NCBI
      -F  FASTQ files (paired-end reads experiments). Comma-separated list
            Paired-end reads experiments should be given in pairs, separated by \":\"
            (example: EXP1_FQ1:EXP1_FQ2,EXP2_FQ1:EXP2_FQ2,EXP3_FQ,EXP4_FQ...)
      -B  BAM files. Comma-separated list
            The file must be sorted by position
            Duplicate reads will be removed unless the -r option is set
      -X  Path to index files (STAR, HISAT2 and BOWTIE2 are supported)
            For BOWTIE2, add to the end of the index path the base name common
             to all the .bt2 files, like /path_to_index_files/hg19
            For HISAT2, add to the end of the index path the base name common
             to all the .ht2 files, like /path_to_index_files/hg19
            For STAR, nothing need to be added to the index path
      -p  (optional) Number of threads to use in parallelized routines
            (it defaults to use all available threads)

    SEQUENCE ALIGNER
      -s  Process RNA-seq experiment using the STAR aligner (34Gb o memory required!)
      -t  Process RNA-seq experiment using the HISAT2 aligner (low memory usage)
      -u  Process experiment using the BOWTIE2 aligner (low memory usage)
          BOWTIE2 is NOT suited for processing of RNA-seq experiments

    SWITCHES
      -h  This help message
      -i  Integrate/Concatenate multiple FASTQ files into one before alignment
            NOTE: It only works if either a list of SRA or FASTQ files is given
            This might be useful when a single GSM id points to multiple SRR ids,
            which are a single FASTQ file split into multiple SRA files
      -a  Align FASTQ files to genome
      -c  Call peaks from BAM file
      -q  Perform quality control of raw-reads (for each FASTQ file)
      -m  Do not trim FASTQ sequences
            (the default behavior is to trim according to FASTQC results)
      -r  Retain duplicate reads in BAM output
            (the default behavior is to remove duplicate reads)
      -x  Print pipeline scheme to the screen
      -y  Generate a default configuration file


$examples

\e[0;33m================================================================================\e[0m\n\n";

	return 1;
}

sub get_examples
{
	my $progName = shift;

	my $examples =
"\e[0;33mEXAMPLES:\e[0m

  Download and generate FASTQ files from SRA ID
    > $progName -I SRR1608989 -C CONFIG.txt

  ChIP-seq experiments or similar:
  Align FASTQ reads to hg19 genome (starting from SRA ID)
    > $progName -I SRR1608989 -C CONFIG.txt -uX path_to_BOWTIE2_aligner_index_files/hg19

  RNA-seq experiments:
  Align FASTQ reads to hg19 genome (starting from SRA ID)
    > $progName -I SRR1608989 -C CONFIG.txt -sX path_to_STAR_aligner_index_files
    > $progName -I SRR1608989 -C CONFIG.txt -tX path_to_HISAT2_aligner_index_files/hg19

  Align to genome using paired-end reads
    > $progName -F SRR1_1.fq.gz:SRR1_2.fq.gz -C CONFIG.txt -sX path_to_STAR_aligner_index_files

  Align to genome using single and paired-end reads from different experiments
    > $progName -F SRR1_1.fq.gz:SRR1_2.fq.gz,SRR2.fq.gz -C CONFIG.txt -sX path_to_STAR_aligner_index_files

  Call peaks on BAM files
    > $progName -cB SRR1.bam,SRR2.bam -C CONFIG.txt\n";

	return $examples;
}

sub print_scheme
{
	my $progName = shift;
	my $version  = shift;
	my $examples = get_examples( $progName );

	print "
\e[0;33m================================================================================\e[0m

\e[0;33m$progName: Pipeline scheme\e[0m

\e[0;33mVersion:    $version\e[0m
\e[0;33mWritten by: Mario Pujato

\e[0;33m================================================================================\e[0m

The pipeline can be used to start and/or generate any intermediate file in the scheme.


\e[1;32m +-------[I]                                     \e[0m
\e[1;32m |         |                                     \e[0m
\e[1;32m |  SRAID  |                                     \e[0m
\e[1;32m |         |                                     \e[0m
\e[1;32m +---------+                                     \e[0m
\e[1;32m      |                                          \e[0m
\e[1;32m      |                                          \e[0m
\e[1;32m      v                                          \e[0m
\e[1;32m +-------[F]       +-------[B]       +---------+ \e[0m
\e[1;32m |         |       |         |       |         | \e[0m
\e[1;32m |  FASTQ  | ----> |   BAM   | ----> |   BED   | \e[0m
\e[1;32m |         |  (a)  |         |  (c)  |         | \e[0m
\e[1;32m +---------+       +---------+       +---------+ \e[0m
\e[1;32m    (q)                 ^                        \e[0m
\e[1;32m                        |                        \e[0m
\e[1;32m                        |                        \e[0m
\e[1;32m                   +-------[X]                   \e[0m
\e[1;32m                   |         |                   \e[0m
\e[1;32m                   |  INDEX  |                   \e[0m
\e[1;32m                   |         |                   \e[0m
\e[1;32m                   +---------+                   \e[0m

Input files:

-I  SRA ID (i.e. SRR1608989 )
-F  Fastq file (paired-end reads should be given separated with \":\", like: FQ1:FQ2)
-B  Alignment file (BAM format)
-C  Configuration file (can be generated with the -y option)
-O  Name of output folder (all files are saved here)

Priority of input files:

  If multiple input files are privided (e.g.: SRA_ID, FASTQ and BAM files),
  the pipeline starts with the file with the highest priority.

  I<F<B (the BAM file has the highest priority)

Genomic index files for short-read aligners:

-X  Index files for corresponding aligner (STAR, HISAT2 and BOWTIE2 are supported)
      For BOWTIE2, add to the end of the index path the base name common
       to all the .bt2 files, like /path_to_index_files/hg19
      For HISAT2, add to the end of the index path the base name common
       to all the .ht2 files, like /path_to_index_files/hg19
      For STAR, nothing need to be added to the index path

Options:

-a  Align FASTQ reads to the genome (generates BAM file)
-c  Call peaks
-p  Number of threads (default: use all available threads)
-q  Perform quality control on FASTQ files
-r  Keep duplicate reads
-s  Input data is RNA-seq (STAR alignment)
-t  Input data is RNA-seq (HISAT2 alignment)
-u  Input data is NOT RNA-seq (BOWTIE2 alignment)

Output files:
(BED) If the -c option is given, MACS2 called peaks are produced as a BED file.
      The BED file has 4 additional columns over the MACS2 output:
         1.  MACS2: chromosome
         2.  MACS2: peak start position
         3.  MACS2: peak end position
         4.  MACS2: peak name
         5.  MACS2: int(-10*log10qvalue)
         6.  MACS2: .
         7.  MACS2: fold-change
         8.  MACS2: -log10pvalue
         9.  MACS2: -log10qvalue
        10.  MACS2: relative summit position to peak start
        11.  Number of reads under the peak
        12.  Peak width
        13.  RPKM, measured as the number of reads divided by the peak width,
             multiplied by 1,000,000 divided by the total number of reads under
             all peaks


$examples

\e[0;33m================================================================================\e[0m\n\n";

	return 1;
}

sub print_configuration_file
{
	my $progName = shift;
	my $version  = shift;

	my $text =
"#|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
# CONFIGURATION FILE
# $progName version $version
#|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||


#===============================================================================
# GENOME FILES
#===============================================================================
# Specify the location of the genome in FASTA format (uncomment to activate)

# HUMAN genome
#-------------------------------------------------------------------------------
REFGEN_FILE  = /data/BCS/Databank/Genomes/hg38/hg38.fa

# MOUSE genome
#-------------------------------------------------------------------------------
#REFGEN_FILE  = /data/BCS/Databank/Genomes/mm10/mm10.fa

# ZEBRAFISH genome
#-------------------------------------------------------------------------------
#REFGEN_FILE  = /data/BCS/Databank/Genomes/danRer7/danRer7.fa



#===============================================================================
# CHROMOSOMES
#===============================================================================
# Chromosomes to consider (comma-separated list)

# HUMAN
#-------------------------------------------------------------------------------
CHROMOSOMES = chr1,chr2,chr3,chr4,chr5,chr6,chr7,chr8,chr9,chr10,chr11,chr12,chr13,chr14,chr15,chr16,chr17,chr18,chr19,chr20,chr21,chr22,chrX,chrY,chrM

# MOUSE
#-------------------------------------------------------------------------------
#CHROMOSOMES = chr1,chr2,chr3,chr4,chr5,chr6,chr7,chr8,chr9,chr10,chr11,chr12,chr13,chr14,chr15,chr16,chr17,chr18,chr19,chrX,chrY,chrM

# ZEBRAFISH
#-------------------------------------------------------------------------------
#CHROMOSOMES = chr1,chr2,chr3,chr4,chr5,chr6,chr7,chr8,chr9,chr10,chr11,chr12,chr13,chr14,chr15,chr16,chr17,chr18,chr19,chr20,chr21,chr22,chr23,chr24,chr25



#===============================================================================
# ANNOTATION
#===============================================================================
# BED files used to annotate final output
# Must have chromosome, start and end positions, followed by annotation fields
# Allelic positions will be annotated using all of the \"ANNO_#\" files given

#ANNO_1 = /home/mario/Documents/CCHMC_postdoc/Projects/Allele_specific_variants/SDataB_VariantsUsedForEachPhenotype.bed
#ANNO_2 = /home/mario/Databases/Hsap/hg19/hg19_exons_anno.bed

#ANNO_1 = /data/weirauchlab/databank/apps/MARIO/SDataB_VariantsUsedForEachPhenotype.bed # Cluster
#ANNO_2 = /data/weirauchlab/databank/apps/MARIO/hg19_exons_anno.bed                     # Cluster



#===============================================================================
# CONFIGURATION PARAMETERS
#===============================================================================

# ADB (Allele-Dependent Behavior) parameters
#-------------------------------------------------------------------------------
S_READS_CF  = 5     # Minimum number of reads (strong reads) to filter out ADB results

# Motif searching parameters
#-------------------------------------------------------------------------------
SNP_PADD    = 20    # Number of base pairs to consider at each side of a SNP for motif searching
                    # Twice this value should encompass the whole length of virtually any motif
MOODS_PVAL  = 0.01  # P-value cutoff for the program MOODS (recommended: 0.01)
MIN_SCORE   = 0.5   # Minimum normalized motif match score to report (it applies to the strong allele)

# Peak extension parameters
#-------------------------------------------------------------------------------
PEAK_EXT = 50    # Number of base pairs to extend called peaks on both sides
                 # MACS2 calls peaks using medium height or something similar
                 # This provides better representation of peak tails

# Peak calling options for MACS2
#-------------------------------------------------------------------------------
# Enter as many modes as you'd like, with the corresponding MACS2 options
# These lines should start with the word \"MODE\". After that you can choose a number or something else

# NOTE: These modes pertain to HUMANs only as they have the option \"-g hs\" in them
# How to specify other organisms:
# -g hs     for human (2.7e9)    (default)
# -g mm     for mouse (1.87e9)
# -g ce     for C. elegans (9e7)
# -g dm     for fruitfly (1.2e8)
# -g 1.5e+9 for Danio rerio
MODE1 = -g hs -q 0.01                                  # Narrow peak calls
MODE2 = -g hs -q 0.01 --broad                          # Broad peak calls
#MODE3 = -g hs -q 0.01 --broad --nomodel --extsize  500 # Broad peak (with no model) calls with peak size of 500bp
#MODE4 = -g hs -q 0.01 --broad --nomodel --extsize 1000 # Broad peak (with no model) calls with peak size of 1000bp



#===============================================================================
# SWITCHES
#===============================================================================
# Switches to save intermediate files
# It only affects intermediate files. Input files are never deleted
# 0 = DISCARD
# 1 = SAVE

SAVE_FASTQ = 1  # Save FASTQ files
SAVE_BAM   = 1  # Save alignment files (BAM format)
SAVE_BED   = 1  # Save peak files (BED format)


#===============================================================================
# EXTERNAL DEPENDENCIES
#===============================================================================
# Include full path if the program is not in the system's PATH variable
# Comments can be added at the end of a command, after a \"#\" sign

FASTQC     = fastqc
VALIDATE   = vdb-validate # Compares checksums for downloaded SRA files
FASTQDUMP  = fastq-dump
TRIMGALORE = trim_galore
CUTADAPT   = cutadapt
#HISAT2     = hisat2 --no-spliced-alignment    # With splice awarenes turned off
HISAT2     = hisat2
BOWTIE2    = bowtie2
#STAR       = STAR --alignSJDBoverhangMin 999  # With splice awarenes turned off
STAR       = STAR --outFilterScoreMinOverLread 0.1 --outFilterMatchNminOverLread 0.1  # Allows short reads to be aligned
SAMTOOLS   = samtools # Version 1.3 or higher
BEDTOOLS   = bedtools
SAMBAMBA   = sambamba -q  # For quite mode use -q
MACS2      = macs2
MOODS      = moods\n";

	my @lines = split( "\n", $text );
	open( OUT, ">CONFIG.txt" ) or
		die "ERROR: Could not write CONFIG.txt file\n";
	print OUT $text;
	close OUT;

	return 1;
}

1;

#-------------------------------------------------------------------------------
package FILE;
use warnings;
use strict;

sub new
{
	my $class     = shift;
	my %arguments = @_;
	my $file      = $arguments{'file'} or
		die "ERROR: Please provide an argument for 'file'\n";
	my $outDir    = $arguments{'outDir'} or
		die "ERROR: Please provide an argument for 'outDir'\n";

	my $self =
	{
		file       => $file,
		directory  => undef,
		base       => undef,
		extension  => undef,
		fileHandle => undef,
		outDir     => $outDir,
	};
	bless( $self, $class );

	$self->_parse_file_name;

	return $self;
}

sub file_exists
{
	my $self = shift;
	my $file = $self->{'file'};

	return 1 if -s $file;
	return 0;
}

sub get_file
{
	my $self = shift;
	return $self->{'file'};
}

sub get_directory
{
	my $self = shift;
	return $self->{'directory'};
}

sub get_name
{
	my $self = shift;
	my $base = $self->{'base'};
	my $ext  = $self->{'extension'};

	return "$base.$ext";
}

sub get_base
{
	my $self = shift;
	return $self->{'base'};
}

sub get_extension
{
	my $self = shift;
	return $self->{'extension'};
}

sub get_outDir
{
	my $self = shift;
	return $self->{'outDir'};
}

sub _parse_file_name
{
	my $self = shift;
	my $file = $self->{'file'};

	# Retrieve file name with full path
	$file    = `readlink -f $file`;
	chomp $file;

	# Extract full path, base name and extension
	$file    =~ /^(.*)\/(.+)\.(\w+)$/;
	my $dir  = $1;
	my $base = $2;
	my $ext  = $3;

	$self->{'directory'} = $dir;
	$self->{'base'}      = $base;
	$self->{'extension'} = $ext;

	return 1;
}

# Make a copy of the file to outDir and
# changes all attributes to point to this file
sub make_copy
{
	my $self   = shift;
	my $outDir = $self->get_outDir;
	my $file   = $self->get_file;
	my $name   = $self->get_name;

	`cp -f "$file" "$outDir/$name"`;

	$self->{'file'} = "$outDir/$name";
	$self->_parse_file_name;

	return 1;
}

sub set_file
{
	my $self = shift;
	my $file = shift;

	$self->{'file'} = $file;
	$self->_parse_file_name;

	return 1;
}

sub Open
{
	my $self = shift;
	my $file = $self->{'file'};

	open( my $FH, $file ) or
		die "ERROR: Could not open file $file\n";
	$self->{'fileHandle'} = $FH;

	return $FH;
}

sub Write
{
	my $self = shift;
	my $file = $self->{'file'};

	open( my $FH, ">$file" ) or
		die "ERROR: Could not open file $file\n";
	$self->{'fileHandle'} = $FH;

	return $FH;
}

sub Close
{
	my $self = shift;
	my $FH   = $self->{'fileHandle'};
	close $FH;

	return 1;
}

1;

#-------------------------------------------------------------------------------
package CONFIGURATION;
use warnings;
use strict;

sub new
{
	my $class     = shift;
	my %arguments = @_;
	my $options   = $arguments{'options'};
    my $outDir    = $arguments{'outDir'};

	my $self = {
		configuration => undef, # {name} = value
	};
	bless( $self, $class );

	# Get input with the highest priority
	$self->_configure( $options );

	return $self;
}

sub set_value
{
	my $self      = shift;
	my $confName  = shift;
	my $confValue = shift;
	my $config    = $self->{'configuration'};

	$config->{$confName} = $confValue;

	return 1;
}

sub get_value
{
	my $self     = shift;
	my $confName = shift;
	my $config   = $self->{'configuration'};

	if( defined $config->{$confName} ){
		return $config->{$confName};
	}
	else{
		return 0;
	}
}

sub _configure
{
	my $self    = shift;
	my $options = shift;
	my %include;

	# Include the pipeline log filehandle
	my $PLOG = $options->{'PLOG'};
	$include{'PLOG'}     = 1;
	$include{'LOGS_DIR'} = 1;

	# Include merge FASTQ files flag
	$include{'i'} = 1;

	# Process input priorities
	# options: 'A > F > S > I'
	#-------------------------
	my $inputFile = 'NONE';

	if( $options->{'B'} ){
		$inputFile      = 'B';
		$include{'B'}   = 1;
		_require_file( $options, 'B' );

		# Include all files that may need to be saved
		$include{'SAVE_BAM'}   = 1;
		$include{'SAVE_BED'}   = 1;

		_load_configuration_file( $options );

		# if the SRA file is given, make sure it's not erased at the end!
		$options->{'SAVE_BAM'} = 1;

		# Call peaks
		_require_c_group_options( $options, \%include );

		# Remove duplicate reads
		_require_r_group_options( $options, \%include );
	}
	elsif( $options->{'F'} ){
		$inputFile    = 'F';
		$include{'F'} = 1;
		_require_file( $options, 'F' );
		# Do not include alignment if only -q option was given
		# It means only QC was requested
		$options->{'a'} = 1
			if ! $options->{'q'};

		# Include alignment if these options are given
		for my $opt ( keys %$options ){
			if( $opt =~ /[stuXc]/ ){
				$options->{'a'} = 1;
			}
		}

		# Include all files that may need to be saved
		$include{'SAVE_FASTQ'} = 1;
		$include{'SAVE_BAM'}   = 1;
		$include{'SAVE_BED'}   = 1;

		_load_configuration_file( $options );

		# if the SRA file is given, make sure it's not erased at the end!
		$options->{'SAVE_FASTQ'} = 1;

		# QC on raw reads
		# Linked to -f option
		_require_q_group_options( $options, \%include )
			if $options->{'q'};

		# Require a-group and/or c-group  options
		if( $options->{'a'} ){
			_require_a_group_options( $options, \%include );
			_require_r_group_options( $options, \%include );
		}

		# Call peaks
		_require_c_group_options( $options, \%include )
			if $options->{'c'};
	}
	elsif( $options->{'I'} ){
		$inputFile    = 'I';
		$include{'I'} = 1;

		# Include all files that may need to be saved
		$include{'SAVE_FASTQ'} = 1;
		$include{'SAVE_BAM'}   = 1;
		$include{'SAVE_BED'}   = 1;

		# Extract config from configuration file
		for my $opt ( keys %$options ){
			if( $opt =~ /[stuXc]/ ){
				$options->{'a'} = 1;
			}
		}
		_load_configuration_file( $options );

		# Include and require VALIDATE to check downloaded SRA file
		$include{'VALIDATE'}   = 1;
		_require_program( $options, 'VALIDATE' );

		# QC on raw reads
		# Linked to -f option
		_require_q_group_options( $options, \%include )
			if $options->{'q'};

		# Extract FASTQ file from SRA file
		_require_program( $options, 'FASTQDUMP' );
		$include{'FASTQDUMP'} = 1;

		# Require a-group and/or c-group  options
		if( $options->{'a'} ){
			_require_a_group_options( $options, \%include );
			_require_r_group_options( $options, \%include );
		}

		# Call peaks
		_require_c_group_options( $options, \%include )
			if $options->{'c'};
	}
	#-------------------------
	$self->{'configuration'}{'iType'} = $inputFile;

	# Include common options
	# Available processors
	my $proc        = `nproc`; chomp $proc;
	$options->{'p'} = $options->{'p'} || $proc;
	$include{'p'}   = 1;
	# output directory
	$options->{'O'} = $options->{'O'} || '.';
	$include{'O'}   = 1;

	print $PLOG  "\n\e[1;31mConfiguration:\e[0m\n\n";
	print STDERR "\n\e[1;31mConfiguration:\e[0m\n\n";
	my @sorted = sort{ $a cmp $b } keys %$options;

	for my $conf ( @sorted ){

		if( $include{$conf} ){
			my $value = $options->{$conf};

			if( defined $value ){
				unless( $conf =~ /MODES|[abcdfnqrst]|PLOG/ ){
					printf $PLOG  ( "%14s: %s\n", $conf, $value );
					printf STDERR ( "%14s: %s\n", $conf, $value );
				}

				if( $conf =~ /MODES/ ){
					my @sorted = sort{ $a cmp $b } keys %$value;

					for my $mode ( @sorted ){
						my $subval = $value->{$mode};
						printf $PLOG  ( "%14s: %s\n", "MACS2_$mode", $subval );
						printf STDERR ( "%14s: %s\n", "MACS2_$mode", $subval );
					}
				}

				if( $conf =~ /CHROMOSOMES/ ){
					my @values = split( ',', $value );
					$value     = \@values;
				}
				$self->{'configuration'}{$conf} = $value;
			}
			else{
				die "ERROR: A value for option \"$conf\" is missing\n";
			}
		}
	}
	print $PLOG  "\n-------------------------------------------------------------------------------\n";
	print STDERR "\n-------------------------------------------------------------------------------\n";

	return 1;
}

sub _load_configuration_file
{
	my $options = shift;
	my $version = $options->{'VERSION'};
	$options->{'C'} = $options->{'C'} || "CONFIG.txt";
	my $PLOG    = $options->{'PLOG'};

	# Require option P
	_require_file( $options, 'C' );

	my $confFile = $options->{'C'};
	open( IN, $confFile ) or
		die "ERROR: Could not open configuration file \"$confFile\"\n";

	while( my $line = <IN> ){
		chomp $line;
		next if $line =~ /^\s*$/;
		next if $line =~ /^\s*#/;

		my $conf  = $line;
		my $value = $line;
		$conf     =~ s/\s*=.*$//;
		$value    =~ s/^.*=\s*//;
		$value    =~ s/\s*#.*$//;

		if( $conf and defined $value ){
			$value          =~ s/\/+$//;
			$options{$conf} = $value;
		}
		else{
			print $PLOG  "WARNING: Failed retrieving configuration line:\n  $line\n";
			print STDERR "WARNING: Failed retrieving configuration line:\n  $line\n";
		}
	}
	close IN;

	return 1;
}

sub _require_file
{
	my $options = shift;
	my $conf    = shift;
	my $addon   = shift;

	if( $options->{$conf} ){
		my @split = split( /[,:]/, $options->{$conf} );

		for my $file ( @split ){
			$file = $options->{$conf} . $addon if $addon;

			# Check file is provided
			die "ERROR: Required file, \"$file\" in option \"$conf\", does not exist\n"
				if !-s $file;
		}
	}
	else{
		die "ERROR: Option \"$conf\" is missing\n";
	}
	return 1;
}

sub _require_program
{
	# Check program exists and it's functional
	my $options = shift;
	my $conf    = shift;
	my $PLOG    = $options->{'PLOG'};
	my $status;

	if( $options->{$conf} ){
		$status = `type -a $options->{$conf} 2> /dev/null`;
	}
	else{
		die "ERROR: Option \"$conf\" is missing\n";
	}

	if( $status ){
		my $version = `$options->{$conf} --version 2> /dev/stdout | grep -v \"^ *\$\" | sed 's|^ *||'`;
		chomp $version;
		print $PLOG  "\n<VERSION START>\nPROGRAM: $options->{$conf}\n$version\n<VERSION END>\n";
		print STDERR "\n<VERSION START>\nPROGRAM: $options->{$conf}\n$version\n<VERSION END>\n";
	}
	else{
		die "ERROR: Required command \"$conf=$options->{$conf}\" not found\n";
	}

	return 1;
}

sub _require_q_group_options
{
	my $options = shift;
	my $include = shift;
	$include->{'m'} = 1 if $options->{'m'};

	_require_program( $options, 'FASTQC' );
	_require_program( $options, 'TRIMGALORE' );
	_require_program( $options, 'CUTADAPT' );

	$include->{'FASTQC'}     = 1;
	$include->{'TRIMGALORE'} = 1;
	$include->{'CUTADAPT'}   = 1;
	$include->{'q'}          = 1;
}

sub _require_c_group_options
{
	my $options     = shift;
	my $include     = shift;
	$include->{'c'} = 1;
	$options->{'a'} = 1;
	$include->{'a'} = 1;

	_require_program( $options, 'MACS2' );
	_require_program( $options, 'SAMTOOLS' );

	# Save modes into hash
	my %modes;
	while( my( $key, $value ) = each %$options ){
		next unless $key =~ /^MODE/;
		$modes{$key} = $value;
	}

	$include->{'SAMTOOLS'}    = 1;
	$include->{'CHROMOSOMES'} = 1;
	$include->{'MACS2'}       = 1;
	$include->{'PEAK_EXT'}    = 1;
	$include->{'PEAK_RPKM'}   = 1;
	$include->{'PEAK_WIDTH'}  = 1;
	$include->{'MODES'}       = 1;

	$options->{'SAVE_BED'}    = 1;
	$options->{'MODES'}       = \%modes;
}

sub _require_a_group_options
{
	my $options     = shift;
	my $include     = shift;
	$options->{'a'} = 1;
	$include->{'a'} = 1;

	_require_file( $options, 'REFGEN_FILE' );
	_require_program( $options, 'SAMTOOLS' );
	_require_program( $options, 'SAMBAMBA' );
	$include->{'SAMTOOLS'}    = 1;
	$include->{'SAMBAMBA'}    = 1;
	$include->{'REFGEN_FILE'} = 1;

	if( $options->{'s'} ){
		_require_file( $options, 'X', '/SAindex' );
		_require_program( $options, 'STAR' );
		$include->{'s'}       = 1;
		$include->{'STAR'}    = 1;
		$include->{'X'}       = 1;
	}
	elsif( $options->{'t'} ){
		_require_file( $options, 'X', '.1.ht2' );
		_require_program( $options, 'HISAT2' );
		$include->{'t'}       = 1;
		$include->{'HISAT2'}  = 1;
		$include->{'X'}       = 1;
	}
	elsif( $options->{'u'} ){
		_require_file( $options, 'X', '.1.bt2' );
		_require_program( $options, 'BOWTIE2' );
		$include->{'u'}       = 1;
		$include->{'BOWTIE2'} = 1;
		$include->{'X'}       = 1;
	}
	else{
		die "ERROR: Missing aligner option\n  Can be any of:\n    -s STAR\n    -t HISAT2\n    -u BOWTIE2\n";
	}
}

sub _require_r_group_options
{
	my $options = shift;
	my $include = shift;
	$include->{'r'} = 1;

	# Remove duplicate reads
	unless( $options->{'r'} ){
		$include->{'SAMBAMBA'} = 1;
		$include->{'SAMTOOLS'} = 1;
	}
}

1;

#-------------------------------------------------------------------------------
package FASTQ;
use base 'FILE';
use warnings;
use strict;

sub new
{
	my $class     = shift;
	my %arguments = @_;
    my $Config    = $arguments{'config'} or
		die "ERROR: Please provide an argument for 'config'\n";
	my $outDir    = $Config->get_value('O');

	# Constructor
	my $self = SUPER::new $class
	(
		file   => 'unavailable',
		outDir => $outDir,
	);
	$self->{'config'} = $Config;
	$self->{'file1'}  = undef;
	$self->{'file2'}  = undef;
	$self->{'qcDir'}  = undef;
	bless( $self, $class );

	return $self;
}

sub destroy
{
	my $self   = shift;
	my $Config = $self->{'config'};
	my $PLOG   = $Config->get_value('PLOG');
	my $file1  = $self->get_file1;
	my $file2  = $self->get_file2;

	print $PLOG  "  Removing FASTQ files\n";
	print STDERR "  Removing FASTQ files\n";

	`rm -f $file1`;
	`rm -f $file2` if $file2;

	return 1;
}

sub get_file1
{
	my $self = shift;
	return $self->{'file1'} || 0;
}

sub get_file2
{
	my $self = shift;
	return $self->{'file2'} || 0;
}

sub get_base1
{
	my $self = shift;
	my $base = $self->{'file1'};
	$base    =~ s/^.*\///;
	$base    =~ s/(.*).f(ast)*q(.gz)*/$1/;

	return $base;
}

sub get_base2
{
	my $self = shift;
	my $base = $self->{'file2'} || 0;
	return 0 unless $base;

	$base    =~ s/^.*\///;
	$base    =~ s/(.*).f(ast)*q(.gz)*/$1/;

	return $base;
}

sub get_qc_dir
{
	my $self = shift;
	return $self->{'qcDir'};
}

sub set_file1
{
	my $self = shift;
	my $file = shift;
	$self->{'file1'} = $file;

	return 1;
}

sub set_file2
{
	my $self = shift;
	my $file = shift;
	$self->{'file2'} = $file;

	return 1;
}

sub quality_control
{
	my $self    = shift;
	my $outDir  = $self->{'outDir'};
	my $Config  = $self->{'config'};
	my $PLOG    = $Config->get_value('PLOG');
	my $logsDir = $Config->get_value('LOGS_DIR');
	my $fastqc  = $Config->get_value('FASTQC');
	print $PLOG  "  Performing quality control ...\n";
	print STDERR "  Performing quality control ...\n";
	my $time0 = time;

	my @qcLogs;
	my @fastqs;
	my @bases;
	push( @fastqs, $self->get_file1 );
	push( @fastqs, $self->get_file2 );
	push( @bases,  $self->get_base1 );
	push( @bases,  $self->get_base2 );
	my $qcErr = "$logsDir/fastqc.stderr";
	my $qcDir = "$outDir/fastqc";
	$self->{'qcDir'} = $qcDir;
	`mkdir -p $qcDir`;
	`rm -f $qcErr 2> /dev/null`;

	for( my $i = 0; $i < scalar @fastqs; $i++ ){
		my $fastq = $fastqs[$i];
		next unless $fastq;

		my $base  = $bases[$i];
		my $qcLog = "$logsDir/$base\_fastqc.log";

		print STDERR "    > $fastq\n";
		print $PLOG  "    COMMAND: $fastqc --extract -o $qcDir -f fastq $fastq\n";
		`echo "> $fastq" >> $qcErr`;
		`$fastqc --extract -o $qcDir -f fastq $fastq 2>> $qcErr | sed 's|^|        |' > /dev/stderr`;
		my $num = `ls $qcDir/$base*_fastqc/summary.txt | wc -l 2> /dev/null`;

		if( !$num ){
			print STDERR "    Unable to QC reads!\n";
			return 0;
		}
		# Output report to STDERR
		my $qcOut = `cut -f1,2 $qcDir/$base*_fastqc/summary.txt 2> /dev/null | sed 's|^|      |' | tail -n12`;
		print $PLOG  "$qcOut"; # Report already contains new lines
		print STDERR "$qcOut"; # Report already contains new lines

		# Save to log file
		`echo $fastq > $qcLog && cut -f1,2 $qcDir/$base*_fastqc/summary.txt >> $qcLog`;
		push( @qcLogs, $qcLog );
	}
	# Remove zipped fastqc file
	`rm -f $qcDir/*.zip`;
	# Move fastqc directory to logsDir
	`mv -f $qcDir/* $logsDir`;
	# Remove fastqc directory
	`rm -rf $qcDir`;

	my $time1   = time;
	my $elapsed = sprintf( "%.2f", ( $time1 - $time0 ) / 60 );
	print $PLOG  "  Time elapsed: $elapsed min\n";
	print STDERR "  Time elapsed: $elapsed min\n";

	return \@qcLogs;
}

sub trim_adapters
{
    my $self    = shift;
    my $qcLogs  = shift;
	my $Config  = $self->{'config'};
	my $PLOG    = $Config->get_value('PLOG');
	my $logsDir = $Config->get_value('LOGS_DIR');

    # Test whether The Kmer content QC failed or not
    # If failed, trim possible adapter sequences
    my $fail = 0;
    for my $qcLog ( @$qcLogs ){
        next unless $qcLog;

        open( IN, $qcLog ) or
            die "ERROR: Failed to open file $qcLog\n";

        while( my $line = <IN> ){
            if( $line =~ /(FAIL|WARN)\tAdapter Content/ ){
                print $PLOG  "  Failed Adapter Content\n";
                print STDERR "  Failed Adapter Content\n";
                $fail++;
            }
            if( $line =~ /FAIL\tPer base sequence quality/ ){
                print $PLOG  "  Failed Per base sequence quality\n";
                print STDERR "  Failed Per base sequence quality\n";
                $fail++;
            }
            if( $line =~ /FAIL\tPer base sequence content/ ){
                print $PLOG  "  Failed Per base sequence content\n";
                print STDERR "  Failed Per base sequence content\n";
                $fail++;
            }
            if( $line =~ /FAIL\tPer sequence quality scores/ ){
                print $PLOG  "  Failed Per sequence quality scores\n";
                print STDERR "  Failed Per sequence quality scores\n";
                $fail++;
            }
        }
        close IN;
    }
    return 1 unless $fail;

    # Kmer content QC failed!
    # Run trim_galore to fix issues
    my $fastq1 = $self->get_file1;
    my $fastq2 = $self->get_file2;
    my $base1  = $self->get_base1;
    my $base2  = $self->get_base2;

    print $PLOG  "  Trimming sequences ...\n";
    print STDERR "  Trimming sequences ...\n";
    my $time0 = time;

    if( $fail > 0 ){
        my $trimGalore = $Config->get_value('TRIMGALORE');
        my $cutadapt   = $Config->get_value('CUTADAPT');
        my $outDir     = $self->{'outDir'};

        # Treat paired-end reads
        if( $fastq2 ){
            my $base1a = $base1;
            $base1a    =~ s/^.*\///;
            my $base2a = $base2;
            $base2a    =~ s/^.*\///;

            # Run trim galore to remove adapters and low quality sequences or segments (for paired-end reads)
            print $PLOG "    COMMAND: $trimGalore -o $outDir --path_to_cutadapt $cutadapt --paired $fastq1 $fastq2\n";
            `$trimGalore -o $outDir --path_to_cutadapt $cutadapt --paired $fastq1 $fastq2 2> $logsDir/trimgalore.stderr`;
            `mv -f $outDir/$base1a*_trimming_report.txt $logsDir/$base1a\_trimgalore.log`;

            if( $Config->get_value('I') ){
                # If FASTQ is an intermediate file, we can remove the orignal and leave the trimmed one
                `rm -f $fastq1 $fastq2 2> /dev/null`;
            }
			# Process the name of the trimmed file
			my $file1 = `ls $outDir\/$base1a*_val_1.fq*`; chomp $file1;
			my $file2 = `ls $outDir\/$base2a*_val_2.fq*`; chomp $file2;

			# Rename the "val_#" files to "trimmed"
			my $nFile1 = $file1;
			my $nFile2 = $file2;
			$nFile1    =~ s/val_1/trimmed/;
			$nFile2    =~ s/val_2/trimmed/;
			`mv -f $file1 $nFile1`;
			`mv -f $file2 $nFile2`;

			$self->set_file1( $nFile1 );
			$self->set_file2( $nFile2 );
        }
        # Treat single-end reads
        else{
            my $base = $base1;
            $base    =~ s/^.*\///;

            # Run trim galore to remove adapters and low quality sequences or segments
            `$trimGalore -o $outDir --path_to_cutadapt $cutadapt $fastq1 2> $logsDir/trimgalore.stderr`;
            `mv -f $outDir/$base*\_trimming_report.txt $logsDir/$base\_trimgalore.log`;

            if( $Config->get_value('I') ){
                # If FASTQ is an intermediate file, we can remove the orignal and leave the trimmed one
                `rm -f $fastq1`;
            }
			# If FASTQ was the input, we keep processing the trimmed file without touching the original
			my $file = `ls $outDir\/$base*_trimmed.fq*`; chomp $file;
			$self->set_file1( $file );
        }
    }
	# Remove intermediate FASTQ files (no longer used)
	`rm -f $fastq1 $fastq2 2> /dev/null` if $Config->get_value('i');

    my $time1   = time;
    my $elapsed = sprintf( "%.2f", ( $time1 - $time0 ) / 60 );
    print $PLOG  "  Time elapsed: $elapsed min\n";
    print STDERR "  Time elapsed: $elapsed min\n";

    return 1;
}

sub generate
{
	my $self      = shift;
	my $sra       = shift;
	my $outDir    = $self->get_outDir;
	my $Config    = $self->{'config'};
	my $PLOG      = $Config->get_value('PLOG');
	my $logsDir   = $Config->get_value('LOGS_DIR');
	my $fastqDump = $Config->get_value('FASTQDUMP');
	my $validate  = $Config->get_value('VALIDATE');
	my $numFiles  = 0;

	print $PLOG  "  Generating FASTQ file ...\n";
	print STDERR "  Generating FASTQ file ...\n";
	my $time0   = time;

	# Download SRA file via fastq-dump
	my $valid;
	my $trial;
	my $limit  = 5;
	my $sraErr = "$logsDir/sra_fastq-dump.stderr";

	# Define FASTQ file names
	my $fastq1 = "$outDir/$sra\_1.fastq.gz";
	my $fastq2 = "$outDir/$sra\_2.fastq.gz";
	
	do{
		$trial++;

		print $PLOG  "    Downloading FASTQ file (trial $trial)\n";
		print STDERR "    Downloading FASTQ file (trial $trial)\n";
		print $PLOG  "      Trying with --split-files option\n";
		print STDERR "      Trying with --split-files option\n";
		print $PLOG  "      COMMAND: $fastqDump -O $outDir --split-files --gzip $sra 2> $sraErr\n";
		`$fastqDump -O \"$outDir\" --split-files --gzip $sra 2> /dev/null  > $sraErr`;

		# Check if SRA file was successfully downloaded
		my $inReads  = `grep \"^Read\"    $sraErr | tail -n1 | cut -d\' \' -f2`; chomp $inReads;
		my $outReads = `grep \"^Written\" $sraErr | tail -n1 | cut -d\' \' -f2`; chomp $outReads;

		# Check for validity of FASTQ sequences after splitting
		my $status1 = check_fastq_file( $fastq1 );
		if( ! $status1 ){
			print $PLOG "ERROR: Invalid FASTQ file 1\n";
			die "ERROR: Invalid FASTQ file 1\n";
		}
		my $status2 = check_fastq_file( $fastq2 );

		# --split-files option returned invalid FASTQ files
		if( $status2 == 2 ){
			`rm -f $fastq1 $fastq2 2> /dev/null`;
			print $PLOG  "      Invalid FASTQ files have been generated\n";
			print STDERR "      Invalid FASTQ files have been generated\n";
			print $PLOG  "      Trying without --split-files option\n";
			print STDERR "      Trying without --split-files option\n";
			# Get FASTQ files without --split-files option
			`echo "Exclude the --split-files option:" >> $sraErr`;
			`echo "COMMAND: $fastqDump -O $outDir --gzip $sra" >> $sraErr`;
			print $PLOG  "      COMMAND: $fastqDump -O $outDir --gzip $sra\n";
			`$fastqDump -O $outDir --gzip $sra 2> /dev/null > $sraErr`;
			$fastq1 =~ s/_1//;

			# Check if SRA file was successfully downloaded
			$inReads  = `grep \"^Read\"    $sraErr | tail -n1 | cut -d\' \' -f2`; chomp $inReads;
			$outReads = `grep \"^Written\" $sraErr | tail -n1 | cut -d\' \' -f2`; chomp $outReads;
		}

		if( $inReads == $outReads ){
			print $PLOG  "      Number of downloaded reads: $outReads\n";
			print STDERR "      Number of downloaded reads: $outReads\n";
			$valid = 1;
		}
		else{
			sleep 5;
		}
	}
	until( $valid or $trial == $limit );

	# Continue if SRA file is valid
	if( $valid ){
		print $PLOG  "      FASTQ files correctly downloaded\n";
		print STDERR "      FASTQ files correctly downloaded\n";
	}
	else{
		# Clean and throw error message
		`rm -f $fastq1 $fastq2 2> /dev/null`;
		die "ERROR: Failed downloading FASTQ files after $trial trials\n";
	}

	$numFiles = `ls $outDir/*.fastq.gz 2> /dev/null | wc -l`;
	chomp $numFiles;

	if( $numFiles == 0 ){
		die "ERROR: Failed generating FASTQ files!\n";
	}
	$self->load_files( $fastq1, $fastq2 );

	# Report time
	my $time1 = time;
	$elapsed  = sprintf( "%.2f", ( $time1 - $time0 ) / 60 );
	print $PLOG  "  Time elapsed: $elapsed min\n";
	print STDERR "  Time elapsed: $elapsed min\n";

	return 1;
}

sub load_files
{
	my $self   = shift;
	my $fastq1 = shift;
	my $fastq2 = shift;

	$self->set_file1( $fastq1 );

	if( -s $fastq2 ){
		$self->set_file2( $fastq2 );
	}

	return 1;
}

sub check_fastq_file
{
	my $file   = shift;
	my $cutoff = 20; # Minimum number of base pairs that would make for a valid sequence

	# Get full path from generated FASTQ files
	my $fastq  = `readlink -f $file 2> /dev/null`;
	chomp $fastq;

	if( -s $fastq ){
		my $baseCount = `zcat $fastq | head -n2 | tail -n1 | wc -c`;
		chomp $baseCount;

		if( $baseCount > $cutoff ){
			# FASTQ file is good
			return 1;
		}
		else{
			# FASTQ file exists, but it's not valid. Therefore, should not use --split-files option)
			return 2;
		}
	}
	else{
		# FASTQ file does not exist
		return 0;
	}
}

1;

#-------------------------------------------------------------------------------
package ALIGNMENT;
use base 'FILE';
use warnings;
use strict;

sub new
{
	my $class     = shift;
	my %arguments = @_;
    my $file      = $arguments{'file'};
    my $Fastq     = $arguments{'fastq'};
    my $Config    = $arguments{'config'} or
		die "ERROR: Please provide an argument for 'config'\n";
	my $outDir    = $Config->get_value('O');
	my $chroms    = $Config->get_value('CHROMOSOMES');
	my $fastq1;
	my $fastq2;

	if( $Fastq ){
		$fastq1  = $Fastq->get_file1;
		$fastq2  = $Fastq->get_file2;
		my $base = $Fastq->get_base1;
		$file    = "$outDir/$base.bam" unless $file;
	}
	die "ERROR: Please provide an argument for 'file' or 'fastq'\n"
		unless $file;

	# Constructor
	my $self = SUPER::new $class
	(
		file   => $file,
		outDir => $outDir,
	);
	$self->{'config'}     = $Config;
	$self->{'file1'}      = $fastq1 || 0;
	$self->{'file2'}      = $fastq2 || 0;
	$self->{'chrFiles'}   = undef;
	$self->{'readLength'} = undef;
	$self->{'bwFile'}     = undef;
	bless( $self, $class );

	return $self;
}

sub destroy_file
{
	my $self = shift;
	return 1;
}

sub destroy_files
{
	my $self   = shift;
	my $files  = $self->{'chrFiles'};
	my $Config = $self->{'config'};
	my $PLOG   = $Config->get_value('PLOG');

	print $PLOG  "  Removing BAM files split by chromosome\n";
	print STDERR "  Removing BAM files split by chromosome\n";
	my @files = values %$files;
	`rm -f @files`;

	return 1;
}

sub get_readLength
{
	my $self = shift;
	return $self->{'readLength'};
}

sub get_file
{
	my $self = shift;
	return $self->{'file'};
}

sub get_chr_files
{
	my $self = shift;
	return $self->{'chrFiles'};
}

sub _get_chroms_from_fa
{
	my $fa_file = shift;
	my $Config  = shift;
	my @chroms  = `grep "^>" $fa_file | grep -oP "chr[\\d\\w]+" | grep -v chrM | sort -Vu`;
	chomp @chroms;
	$Config->set_value( 'CHROMOSOMES', \@chroms );

	return 1;
}

sub get_bwig_file
{
	my $self = shift;
	return $self->{'bwFile'};
}

sub make_bigwig
{
	my $self     = shift;
	my $bamFile  = $self->get_file;

	my $Config   = $self->{'config'};
	my $PLOG     = $Config->get_value('PLOG');
	my $bedtools = $Config->get_value('BEDTOOLS');
	my $bedG2BW  = $Config->get_value('BEDG2BWIG');
	my $chrSizes = $Config->get_value('CHRSIZES');

	my $time0    = time;

	print $PLOG  "  Making BigWig file from BAM file $bamFile\n";
	print STDERR "  Making BigWig file from BAM file $bamFile\n";
	my $bwFile   = $bamFile;
	$bwFile      =~ s/bam$/bw/;
	print $PLOG "    COMMAND: $bedtools bamtobed -i $bamFile > $bamFile.bed\n";
	print $PLOG "    COMMAND: $bedG2BW $bamFile.bed $chrSizes $bwFile\n";
	`$bedtools bamtobed -i $bamFile > $bamFile.bed`;
	`$bedG2BW $bamFile.bed $chrSizes $bwFile`;

	# Check bwFile was generated correctly
	if( -s $bwFile ){
		print $PLOG  "  BigWig file $bwFile created\n";
		print STDERR "  BigWig file $bwFile created\n";
		`rm -f $bamFile.bed`;
	}
	else{
		print $PLOG  "ERROR: Failed to create BigWig file $bwFile\n";
		print STDERR "ERROR: Failed to create BigWig file $bwFile\n";
		return 0;
	}

	# Save BWIG file to object
	$self->{'bwFile'} = $bwFile;

	my $time1    = time;
	my $elapsed  = sprintf( "%.2f", ( $time1 - $time0 ) / 60 );
	print $PLOG  "  Time elapsed: $elapsed min\n";
	print STDERR "  Time elapsed: $elapsed min\n";

	return 1;
}

sub align_to_genome
{
	my $self     = shift;
	my $fastq1   = $self->{'file1'};
	my $fastq2   = $self->{'file2'} || 0;
	my $bamFile  = $self->{'file'};
	my $base     = $bamFile;
	$base        =~ s/^.*\///;
	$base        =~ s/\.bam$//;

	my $Config   = $self->{'config'};
	my $PLOG     = $Config->get_value('PLOG');
	my $logsDir  = $Config->get_value('LOGS_DIR');
	my $samtools = $Config->get_value('SAMTOOLS');
	my $genome   = $Config->get_value('REFGEN_FILE');
	my $outDir   = $Config->get_value('O');
	my $index    = $Config->get_value('X');
	my $rnaseq   = $Config->get_value('r');
	my $proc     = $Config->get_value('p');

	my $gVersion = $genome;
	$gVersion    =~ s/^.*\///;
	$gVersion    =~ s/\.fa.*$//;

	my $time0      = time;
	my $numAligned = 0;
	my $totalReads = 0;

	# Detect paired-end or single-end reads
	my $pe_flag = 0;
	if( $fastq2 ){
		$pe_flag = 1;
		print $PLOG  "  Aligning paired-end reads to $gVersion\n";
		print STDERR "  Aligning paired-end reads to $gVersion\n";
	}
	else{
		print $PLOG  "  Aligning single-end reads to $gVersion\n";
		print STDERR "  Aligning single-end reads to $gVersion\n";
	}

	# Check for gzipped files
	my $gz_flag = 0;
	if( $fastq1 =~ /\.gz/ ){
		print $PLOG  "    FASTQ files are compressed\n";
		print STDERR "    FASTQ files are compressed\n";
		$gz_flag = 1;
	}

	# Use STAR with RNA-seq alignment (memory intensive! >32GB)
	if( $Config->get_value('s') ){
		my $star      = $Config->get_value('STAR');
		my $modifiers = "--outSAMtype BAM SortedByCoordinate --outSAMmultNmax 1 --outMultimapperOrder Random";
#		$modifiers   .= " --outSAMunmapped Within KeepPairs"; # Save unmmaped reads within the BAM file
		$modifiers   .= " --outReadsUnmapped Fastx";
		$modifiers   .= " --readFilesCommand zcat" if $gz_flag;
	 	$modifiers   .= " --outFileNamePrefix $outDir/";
		my $fastqs    = $fastq1;
		$fastqs      .= " $fastq2" if $pe_flag;

		# Run STAR aligner
		#-----------------------------------------------------------------------
		print $PLOG "    COMMAND: $star --runThreadN $proc $modifiers --genomeDir $index --readFilesIn $fastqs\n";
		`$star --runThreadN $proc $modifiers --genomeDir $index --readFilesIn $fastqs 2> $logsDir/$base\_star.stderr`;
		#-----------------------------------------------------------------------
		$totalReads  = `grep "Number of input reads"        $outDir/Log.final.out | cut -f2`; chomp $totalReads;
		$numAligned  = `grep "Uniquely mapped reads number" $outDir/Log.final.out | cut -f2`; chomp $numAligned;

		# Rename BAM file
		`mv -f $outDir/Aligned.sortedByCoord.out.bam $bamFile 2> /dev/null`;

		# Rename unmapped FASTQ files
		my $unmapped1 = "$outDir/Unmapped.out.mate1";
		my $unmapped2 = "$outDir/Unmapped.out.mate2";

		if( -s $unmapped1 ){
			`mv -f $unmapped1 $outDir/$base\_unmapped_R1.fastq`;
			`gzip             $outDir/$base\_unmapped_R1.fastq`;
		}
		if( -s $unmapped2 ){
			`mv -f $unmapped2 $outDir/$base\_unmapped_R2.fastq`;
			`gzip             $outDir/$base\_unmapped_R2.fastq`;
		}

		# Save relevant STAR output files
		`mv -f $outDir/Log.final.out $logsDir/$base\_star.log 2> /dev/null`;
		`rm -rf $outDir/*.tab $outDir/_STARtmp $outDir/*.out 2> /dev/null`;
		`rm -f $logsDir/$base\_star.stderr 2> /dev/null` if ! -s "$logsDir/$base\_star.stderr";
	}
	# Use HISAT2 to align RNA-seq
	elsif( $Config->get_value('t') ){
		my $hisat2    = $Config->get_value('HISAT2');
		my $logFile   = "$logsDir/$base\_hisat2.log";
		my $modifiers = "--no-unal";
		my $fastqs    = "-U $fastq1";

		if( $pe_flag ){
			$modifiers .= " --no-discordant --no-mixed";
			$modifiers .= " --un-conc-gz $outDir/$base";
			$fastqs     = "-1 $fastq1 -2 $fastq2";
		}
		else{
			$modifiers .= " --un-gz $outDir/$base";
		}

		# Run HISAT2 aligner
		#-----------------------------------------------------------------------
		print $PLOG "    COMMAND: $hisat2 -p $proc $modifiers -x $index $fastqs 2> $logFile | $samtools view -bS - > $bamFile\n";
		`$hisat2 -p $proc $modifiers -x $index $fastqs 2> $logFile | $samtools view -bS - > $bamFile 2> $logsDir/alignment_hisat2.stderr`;
		#-----------------------------------------------------------------------
		$totalReads = `grep "reads; of these:" $logFile | sed 's|^ *||' | cut -d' ' -f1`; chomp $totalReads;
		$numAligned = `grep -A1 "exactly" $logFile | sed 's|^ *||' | cut -d' ' -f1 | paste -sd+ | bc`; chomp $numAligned;

		# Rename unmapped FASTQ files
		if( $pe_flag ){
			my $unmapped1 = "$outDir/$base.1";
			my $unmapped2 = "$outDir/$base.2";
			`mv -f $unmapped1 $outDir/$base\_unmapped_R1.fastq.gz` if -s $unmapped1;
			`mv -f $unmapped2 $outDir/$base\_unmapped_R2.fastq.gz` if -s $unmapped2;
		}
		else{
			my $unmapped = "$outDir/$base";
			`mv -f $unmapped $outDir/$base\_unmapped_R1.fastq.gz` if -s $unmapped;
		}
	}
	# Align with BOWTIE2
	elsif( $Config->get_value('u') ){
		my $bowtie2   = $Config->get_value('BOWTIE2');
		my $logFile   = "$logsDir/$base\_bowtie2.log";

		my $modifiers = "--no-unal";
		my $fastqs    = "-U $fastq1";

		if( $pe_flag ){
			$modifiers .= " --no-discordant --no-mixed";
			$modifiers .= " --un-conc-gz $outDir/$base";
			$fastqs     = "-1 $fastq1 -2 $fastq2";
		}
		else{
			$modifiers .= " --un-gz $outDir/$base";
		}

		# Run BOWTIE2 aligner
		#-----------------------------------------------------------------------
		print $PLOG "    COMMAND: $bowtie2 -p $proc $modifiers -x $index $fastqs 2> $logFile | $samtools view -bS - > $bamFile\n";
		`$bowtie2 -p $proc $modifiers -x $index $fastqs 2> $logFile | $samtools view -bS - > $bamFile 2> $logsDir/alignment_bowtie2.stderr`;
		#-----------------------------------------------------------------------
		$totalReads = `grep "reads; of these:" $logFile | sed 's|^ *||' | cut -d' ' -f1`; chomp $totalReads;
		$numAligned = `grep -A1 "exactly" $logFile | sed 's|^ *||' | cut -d' ' -f1 | paste -sd+ | bc`; chomp $numAligned;

		# Rename unmapped FASTQ files
		if( $pe_flag ){
			my $unmapped1 = "$outDir/$base.1";
			my $unmapped2 = "$outDir/$base.2";
			`mv -f $unmapped1 $outDir/$base\_unmapped_R1.fastq.gz` if -s $unmapped1;
			`mv -f $unmapped2 $outDir/$base\_unmapped_R2.fastq.gz` if -s $unmapped2;
		}
		else{
			my $unmapped = "$outDir/$base";
			`mv -f $unmapped $outDir/$base\_unmapped_R1.fastq.gz` if -s $unmapped;
		}
	}

	if( $numAligned ){
		my $perc_aligned   = sprintf( "%.1f", $numAligned / $totalReads * 100 );
		print $PLOG  "    Aligned reads = $numAligned ($perc_aligned%)\n";
		print STDERR "    Aligned reads = $numAligned ($perc_aligned%)\n";
		$self->{'aligned'} = $numAligned;
		$self->{'file'}    = $bamFile;
	}
	else{
		die "Reads aligned: 0 out of $totalReads\n";
	}
	# Remove intermediate FASTQ files (no longer used)
	`rm -f $fastq1 $fastq2 2> /dev/null` if $Config->get_value('i');

	my $time1   = time;
	my $elapsed = sprintf( "%.2f", ( $time1 - $time0 ) / 60 );
	print $PLOG  "  Time elapsed: $elapsed min\n";
	print STDERR "  Time elapsed: $elapsed min\n";

	return 1;
}

sub _count_aligned_reads
{
	my $bamFile    = shift;
	my $Config     = shift;
	my $splitErr   = shift;
	my $samtools   = $Config->get_value('SAMTOOLS');
	my $numAligned = 0;

	`echo "$samtools view $bamFile | wc -l" >> $splitErr`;
	$numAligned    = `$samtools view $bamFile 2>> $splitErr | wc -l`;
	chomp $numAligned;

	return $numAligned;
}

sub sort_bam
{
	my $self     = shift;
	my $bamFile  = $self->{'file'};
	my $Config   = $self->{'config'};
	my $PLOG     = $Config->get_value('PLOG');
	my $logsDir  = $Config->get_value('LOGS_DIR');
	my $sambamba = $Config->get_value('SAMBAMBA');
	my $samtools = $Config->get_value('SAMTOOLS');
	my $proc     = $Config->get_value('p');
	my $sortErr  = "$logsDir/sort_bam.stderr";

	# Check if BAM file is sorted
	`echo "$samtools view -H $bamFile" > $sortErr`;
	my $sorted = `$samtools view -H $bamFile 2>> $sortErr | grep -oP "SO:\\w+"`;
	if( $sorted =~ /SO:coordinate/ ){
		print $PLOG  "    BAM file is sorted\n";
		print STDERR "    BAM file is sorted\n";
		return 1;
	}

	print $PLOG  "  Sorting BAM file ...\n";
	print STDERR "  Sorting BAM file ...\n";
	my $time0  = time;

	# Sort BAM file using samtools
	print $PLOG "    COMMAND: $sambamba sort -t $proc -o $bamFile.sorted $bamFile\n";
	`echo "$sambamba sort -t $proc -o $bamFile.sorted $bamFile" 2>> $sortErr`;
	`$sambamba sort -t $proc -o $bamFile.sorted $bamFile 2>> $sortErr`;
	`mv $bamFile.sorted $bamFile`;
	`mv $bamFile.sorted.bai $bamFile.bai`;

	# Check again if BAM file is sorted
	`echo "$samtools view -H $bamFile" >> $sortErr`;
	$sorted    = `$samtools view -H $bamFile 2>> $sortErr | grep -oP "SO:\\w+"`;
	if( $sorted =~ /SO:coordinate/ ){
		print $PLOG  "    BAM file successfully sorted\n";
		print STDERR "    BAM file successfully sorted\n";
	}
	else{
		print $PLOG  "    ERROR: Failed to sort BAM file!\n";
		die "ERROR: Failed to sort BAM file!\n";
	}

	my $time1   = time;
	my $elapsed = sprintf( "%.2f", ( $time1 - $time0 ) / 60 );
	print $PLOG  "  Time elapsed: $elapsed min\n";
	print STDERR "  Time elapsed: $elapsed min\n";

	return 1;
}

sub index_bam
{
	my $self     = shift;
	my $bamFile  = $self->{'file'};
	my $Config   = $self->{'config'};
	my $PLOG     = $Config->get_value('PLOG');
	my $logsDir  = $Config->get_value('LOGS_DIR');
	my $samtools = $Config->get_value( 'SAMTOOLS' );
	my $indexErr = "$logsDir/index_bam.stderr";

	print $PLOG  "  Indexing BAM file $bamFile\n";
	print STDERR "  Indexing BAM file $bamFile\n";
	my $time0    = time;

	if( !-s "$bamFile.bai" ){
		# Indexing
		print $PLOG "$samtools index $bamFile\n";
		`echo "$samtools index $bamFile" > $indexErr`;
		`$samtools index $bamFile 2>&1 >> $indexErr`;
	}

	if( !-s "$bamFile.bai" ){
		print $PLOG  "    Failed!\n";
		print STDERR "    Failed!\n";
		return 0;
	}

	my $time1   = time;
	my $elapsed = sprintf( "%.2f", ( $time1 - $time0 ) / 60 );
	print $PLOG  "  Time elapsed: $elapsed min\n";
	print STDERR "  Time elapsed: $elapsed min\n";

	return 1;
}

sub remove_duplicates
{
	my $self     = shift;
	my $bamFile  = $self->get_file;
	my $base     = $self->get_base;
	my $readLen  = $self->{'readLength'};
	my $Config   = $self->{'config'};
	my $PLOG     = $Config->get_value('PLOG');
	my $samtools = $Config->get_value('SAMTOOLS');
	my $outDir   = $Config->get_value('O');
	my $proc     = $Config->get_value('p');

	print $PLOG  "  Removing duplicate reads ...\n";
	print STDERR "  Removing duplicate reads ...\n";
	my $time0 = time;

	# Remove duplicate reads by chromosome, position and sequence
	my(
	 	$reads,
		$dups,
		$percDup,
	) = _remove_duplicate_reads( $self );
	die "    Failed!\n" if !$reads;

	my $dReads  = $reads - $dups;
	print $PLOG  "    Unique reads returned = $dReads ($percDup%)\n";
	print STDERR "    Unique reads returned = $dReads ($percDup%)\n";
	$self->{'aligned_filt'} = $dReads;

	my $time1   = time;
	my $elapsed = sprintf( "%.2f", ( $time1 - $time0 ) / 60 );
	print $PLOG  "  Time elapsed: $elapsed min\n";
	print STDERR "  Time elapsed: $elapsed min\n";

	return 1;
}

sub _remove_duplicate_reads
{
	my $self     = shift;
	my $bamFile  = $self->get_file;
	my $base     = $self->get_base;
	my $readLen  = $self->{'readLength'};
	my $Config   = $self->{'config'};
	my $PLOG     = $Config->get_value('PLOG');
	my $logsDir  = $Config->get_value('LOGS_DIR');
	my $sambamba = $Config->get_value('SAMBAMBA');
	my $outDir   = $Config->get_value('O');
	my $proc     = $Config->get_value('p');
	my $bamDedup = "$outDir/$base\_dedup.bam";
	my $sambLog  = "$logsDir/$base\_sambamba.log";

	print $PLOG "    COMMAND: $sambamba markdup -r -t $proc $bamFile $bamDedup 2> $sambLog\n";
	`$sambamba markdup -r -t $proc $bamFile $bamDedup 2> $sambLog`;
	die "    Failed!\n" unless -s $bamDedup;
	`mv -f $bamDedup $bamFile 2> /dev/null`;
	`mv -f $bamDedup.bai $bamFile.bai 2> /dev/null`;

	# Read sambamba log and extract values to calculate percent duplication
	# All reads are expressed as single-end reads
	open( IN, $sambLog ) or die "ERROR: Could not read sambamba log file: $sambLog\n";
	my %reads;
	my $pairedEnd = 0;

	for my $line ( <IN> ){
		chomp $line;
		if( $line =~ /sorted (\d+) end pairs/ ){
			my $reads = $1;
			$reads{'input'}  = 2*$reads;
			$pairedEnd = 1 if $reads > 0;
		}
		elsif( $line =~ /and (\d+) single ends/ ){
			$reads{'input'} += $1;
		}
		elsif( $line =~ /found (\d+) duplicates/ ){
			$reads{'dups'}   = $1;
		}
	}

	my $mult    = 1;
	$mult       = 2 if $pairedEnd == 1;
	my $reads   = sprintf( "%u", $reads{'input'}/$mult );
	my $dups    = sprintf( "%u", $reads{'dups'}/$mult );
	my $percDup = sprintf( "%.1f", 100*(1-$dups/$reads) );

	return(
	 	$reads,
		$dups,
		$percDup,
	);
}

sub get_length_of_largest_read
{
	my $self     = shift;
	my $bamFile  = $self->{'file'};
	my $Config   = $self->{'config'};
	my $PLOG     = $Config->get_value('PLOG');
	my $samtools = $Config->get_value('SAMTOOLS');

	# Get length of largest read
	print $PLOG  "  Getting largest read length\n";
	print STDERR "  Getting largest read length\n";

	my $readLength = `$samtools view $bamFile | head -n100000 | cut -f6 | grep -oP "^\\d+" | sort -nru | head -n1`;
	chomp $readLength;

	if( !$readLength ){
		print $PLOG  "\n    Failed retrieving read length!\n";
		print STDERR "\n    Failed retrieving read length!\n";
		return 0;
	}
	$self->{'readLength'} = $readLength;

	print $PLOG  "    Read length = $readLength bp\n";
	print STDERR "    Read length = $readLength bp\n";
	return 1;
}

sub split_bam_by_chr
{
	my $self     = shift;
	my $bamFile  = $self->get_file;
	my $base     = $self->get_base;
	my $Config   = $self->{'config'};
	my $PLOG     = $Config->get_value('PLOG');
	my $logsDir  = $Config->get_value('LOGS_DIR');
	my $samtools = $Config->get_value('SAMTOOLS');
	my $chroms   = $Config->get_value('CHROMOSOMES');
	my $outDir   = $Config->get_value('O');
	my $proc     = $Config->get_value('p');
	my $splitErr = "$logsDir/split_bam.stderr";
	my %chrFiles;

	print $PLOG  "  Split BAM file by chromosomes ...\n";
	print STDERR "  Split BAM file by chromosomes ...\n";
	my $time0 = time;

	# Indexing
	print $PLOG  "    Indexing BAM file\n";
	print STDERR "    Indexing BAM file\n";
	`rm -f $bamFile.bai`;
	`echo "$samtools index $bamFile" > $splitErr`;
	`$samtools index $bamFile 2>&1 >> $splitErr`;

	# Sort BAM file
	$self->sort_bam;

	for my $chr ( @$chroms ){
		my $chrBamFile = "$outDir/$chr\_$base.bam";

		# Split BAM file
		if( !-s $chrBamFile ){
			print $PLOG "    COMMAND: $samtools view $bamFile $chr -b > $chrBamFile\n";
			`echo "$samtools view $bamFile $chr -b > $chrBamFile" >> $splitErr`;
			`$samtools view $bamFile $chr -b > $chrBamFile 2>> $splitErr`;
		}

		# Count number of reads in this chromosome
		my $num_reads = _count_aligned_reads( $chrBamFile, $Config, $splitErr );
		my $answer    = "    No reads aligned to $chr\n";

		if( $num_reads ){
			$answer = "    Number of reads in $chr = $num_reads\n";
			$chrFiles{$chr} = $chrBamFile;
		}
		else{
			`rm -f $chrBamFile`;
		}
		print $PLOG  $answer;
		print STDERR $answer;
	}

	if( keys %chrFiles ){
		my $time1   = time;
		my $elapsed = sprintf( "%.2f", ( $time1 - $time0 ) / 60 );
		print $PLOG  "  Time elapsed: $elapsed min\n";
		print STDERR "  Time elapsed: $elapsed min\n";
		$self->{'chrFiles'} = \%chrFiles;

		return 1;
	}
	else{
		print $PLOG  "  Failed splitting BAM file!\n";
		print STDERR "  Failed splitting BAM file!\n";
		return 0;
	}
}

sub _get_chroms_from_bam
{
	my $bamFile  = shift;
	my $Config   = shift;
	my $samtools = $Config->get_value('SAMTOOLS');
	my @chroms   = `$samtools view -H $bamFile | grep "^\@SQ" | grep -v chrM | cut -f2 | cut -d: -f2`;
	chomp @chroms;
	$Config->set_value( 'CHROMOSOMES', \@chroms );

	return 1;
}

1;

#-------------------------------------------------------------------------------
package PEAKS;
use base 'FILE';
use warnings;
use strict;

sub new
{
	my $class     = shift;
	my %arguments = @_;
    my $bamFile   = $arguments{'bamFile'} or
		die "ERROR: Please provide an argument for 'bamFile'\n";
    my $Config    = $arguments{'config'}  or
		die "ERROR: Please provide an argument for 'config'\n";
	my $outDir    = $Config->get_value('O');
	my $chroms    = $Config->get_value('CHROMOSOMES');

	# Peak types: {type}=mods
	my $peakTypes = $Config->get_value('MODES');

	my $base = $bamFile;
	$base    =~ s/^.*\///;
	$base    =~ s/.bam$//;
	my %peakFiles;
	my %chrFiles;

	while( my( $type, $mod ) = each %$peakTypes ){
		my $bedFile = "$outDir/$base\_$type.bed";
		$peakFiles{$type} = $bedFile;

		for my $chr ( @$chroms ){
			$chrFiles{$type}{$chr} = "$outDir/$chr\_$base\_$type.bed";
		}
	}

	# Constructor
	my $self = SUPER::new $class(
	 	file   => 'dummyFileName',
		outDir => $outDir,
	);
	$self->{'files'}     = \%peakFiles;
	$self->{'config'}    = $Config;
	$self->{'chrFiles'}  = \%chrFiles;
	$self->{'bamFile'}   = $bamFile;
	$self->{'peakTypes'} = $peakTypes;
	bless( $self, $class );

	return $self;
}

sub destroy_files
{
	my $self   = shift;
	my $files  = $self->{'files'};
	my $Config = $self->{'config'};
	my $PLOG   = $Config->get_value('PLOG');

	print $PLOG  "  Removing PEAK files\n";
	print STDERR "  Removing PEAK files\n";
	while( my( $type, $file ) = each %$files ){
		`rm -f $file`;
	}

	return 1;
}

sub destroy_chr_files
{
	my $self   = shift;
	my $files  = $self->{'chrFiles'};
	my $Config = $self->{'config'};
	my $PLOG   = $Config->get_value('PLOG');

	print $PLOG  "  Removing PEAK files split by chromosome\n";
	print STDERR "  Removing PEAK files split by chromosome\n";
	while( my( $type, $chrFiles ) = each %$files ){
		while( my( $chr, $file )  = each %$chrFiles ){
			`rm -f $file`;
		}
	}

	return 1;
}

sub get_file
{
	my $self = shift;
	my $type = shift;
	return $self->{'files'}{$type};
}

sub get_chr_files
{
	my $self = shift;
	my $type = shift;
	return $self->{'chrFiles'}{$type};
}

sub get_peak_types
{
	my $self = shift;
	return $self->{'peakTypes'};
}

sub call_peaks
{
	my $self      = shift;
	my $type      = shift;
	my $outDir    = $self->get_outDir;
	my $peakTypes = $self->{'peakTypes'};
	my $bamFile   = $self->{'bamFile'};

	my $Config    = $self->{'config'};
	my $PLOG      = $Config->get_value('PLOG');
	my $logsDir   = $Config->get_value('LOGS_DIR');
	my $chroms    = $Config->get_value('CHROMOSOMES');
	my $proc      = $Config->get_value('p');
	my $macs2     = $Config->get_value('MACS2');
	my $extend    = $Config->get_value('PEAK_EXT');

	print $PLOG  "  Calling $type peaks ...\n";
	print STDERR "  Calling $type peaks ...\n";
	my $time0 = time;

	# Call peaks on BAM file using MACS2
	my $peakFile = $self->get_file( $type );

	# Get basename of peakFile
	my $logFile  = $peakFile;
	my $baseFile = $peakFile;
	$baseFile    =~ s/_$type.bed$/_macs2tmp/;
	$logFile     =~ s/.bed$/_macs2.log/;
	$logFile     =~ s/^.*\//$logsDir\//;

	# Run MACS2
	my $mod = $peakTypes->{$type};
	print $PLOG "    COMMAND: $macs2 callpeak $mod -t $bamFile -f BAM -n $baseFile\n";
	`$macs2 callpeak $mod -t $bamFile -f BAM -n $baseFile 2> $logFile`;
	`rm -f $outDir/*macs2tmp*gapped*`;
	`mv -f $baseFile\_peaks.*Peak $peakFile`;

	# Remove unnecessary files form MACS2
	`rm -f $outDir/*macs2tmp*`;

	# Modify a few things in the BED file
	if( -s $peakFile ){
		# Eliminate path in BED file so it takes less space in disk
		`sed -i 's|$baseFile\_||' $peakFile`;
		# Extend peaks by $extend bp on both sides
		`awk '{print \$1,\$2-$extend,\$3+$extend,\$0}' OFS='\\t' $peakFile | cut -f1-3,7- > $peakFile.tmp`;
		`mv $peakFile.tmp $peakFile`;

		# Report number of peaks (if any)
		my $numPeaks = _get_number_of_peaks( $peakFile );
		my $answer   = "    No peaks found!\n";
		$answer      = "    Total number of peaks = $numPeaks\n" if $numPeaks;
		print $PLOG  $answer;
		print STDERR $answer;
	}
	else{
		print $PLOG  "    Failed to call $type peaks!\n";
		print STDERR "    Failed to call $type peaks!\n";
	}
	my $time1    = time;
	my $elapsed  = sprintf( "%.2f", ( $time1 - $time0 ) / 60 );
	print $PLOG  "  Time elapsed: $elapsed min\n";
	print STDERR "  Time elapsed: $elapsed min\n";

	return 1;
}

sub split_peaks_by_chr
{
	my $self      = shift;
	my $type      = shift;
	my $outDir    = $self->get_outDir;
	my $chrFiles  = $self->{'chrFiles'};
	my $Config    = $self->{'config'};
	my $PLOG      = $Config->get_value('PLOG');
	my $chroms    = $Config->get_value('CHROMOSOMES');
	my %chrFiles;

	print $PLOG  "  Splitting peak file by chromosomes ...\n";
	print STDERR "  Splitting peak file by chromosomes ...\n";
	my $time0 = time;

	# Split PEAK file by chromosomes
	my $peakFile = $self->{'files'}->{$type};

	if( !-s $peakFile ){
		print $PLOG  "    No peak file $peakFile found!\n";
		print STDERR "    No peak file $peakFile found!\n";
		return 0;
	}

	# Get chrPeakFiles
	for my $chr ( @$chroms ){
		my $chrPeakFile = $chrFiles->{$type}{$chr};
		`grep -P "^$chr\\t" $peakFile | awk '{if(\$2>0) print \$0}' > $chrPeakFile`;

		my $numPeaks = _get_number_of_peaks( $chrPeakFile );
		my $answer   = "    No peaks found for $chr\n";

		if( $numPeaks ){
			$answer = "    Number of peaks in $chr = $numPeaks\n";
		}
		else{
			`rm -f $chrPeakFile`;
		}
		print $PLOG  $answer;
		print STDERR $answer;
	}
	my $time1   = time;
	my $elapsed = sprintf( "%.2f", ( $time1 - $time0 ) / 60 );
	print $PLOG  "  Time elapsed = $elapsed min\n";
	print STDERR "  Time elapsed = $elapsed min\n";

	return 1;
}

sub _get_number_of_peaks
{
	my $peakFile = shift;
	my $numPeaks = 0;

	if( -s $peakFile ){
		$numPeaks = `cat $peakFile | wc -l`;
		chomp $numPeaks;
	}

	return $numPeaks;
}

sub count_reads_under_peak
{
	my $self      = shift;
	my $bamFiles  = shift;
	my $type      = shift;
	my $peakFile  = $self->get_file( $type );
	my $peakFiles = $self->get_chr_files( $type );
	my $outDir    = $self->get_outDir;
	my $peakBase  = $peakFile;
	$peakBase     =~ s/^.*\///;
	$peakBase     =~ s/\.bed$//;

	my $Config    = $self->{'config'};
	my $PLOG      = $Config->get_value('PLOG');
	my $extend    = $Config->get_value('PEAK_EXT');
	my $minRpkm   = $Config->get_value('PEAK_RPKM');
	my $minWidth  = $Config->get_value('PEAK_WIDTH');
	my $minReads  = $Config->get_value('PEAK_READS');
	my $samtools  = $Config->get_value('SAMTOOLS');
	my $chroms    = $Config->get_value('CHROMOSOMES');
	my $proc      = $Config->get_value('p');

	print $PLOG  "  Counting reads under called peaks ...\n";
	print STDERR "  Counting reads under called peaks ...\n";
	my $time0 = time;

	my $pm = new Parallel::ForkManager( $proc );

	for my $chr ( @$chroms ){
		$pm->start and next;

		if( -s $peakFiles->{$chr} ){
			my $chrPeakFile  = $peakFiles->{$chr};
			my $chrBamFile   = $bamFiles->{$chr};
			my $chrCountFile = "$chrPeakFile.count";

			open( PEAK, "$chrPeakFile" ) or
				die "ERROR: Could not open file $chrPeakFile";
			open( BAM, "$samtools view $chrBamFile |" ) or
				die "ERROR: Could not open file $chrBamFile\n";
			open( OUT, ">$chrCountFile" ) or
				die "ERROR: Could not open file $chrCountFile\n";

			while( my $peak_line = <PEAK> ){
				chomp $peak_line;
				my(
					$p_chr,
					$p_start,
					$p_end,
					$p_id,
					$p_score,
					$p_strand,
					$p_foldchange,
					$p_pvalue,
					$p_qvalue,
					$p_summit,
				) = split( "\t", $peak_line );
				$p_summit      = $p_summit || 'NA';
				my $read_count = 0;
				my $state      = 0;

				do{
					my $bam_line = <BAM>;

					if( $bam_line ){
						chomp $bam_line;
						# SRR873824.24745869  0   chr22   16051210
						my @split   = split( "\t", $bam_line );

						# Filter by CIGAR line (exclude rare alignments)
						my $cigar   = $split[5];
						next if $cigar !~ /^(\d+[MSHIND])+$/;

						my $r_chr   = $split[2];
						my $r_start = $split[3];
						my $r_seq   = $split[9];
						my $r_len   = length $r_seq;
						my $r_end   = $r_start + $r_len - 1;

						if( $r_end >= $p_start ){
							if( $r_end >= $p_start and $r_start <= $p_end ){
								$read_count++;
							}
							else{
								my @p_data = (
									$p_chr,
									$p_start,
									$p_end,
									$p_id,
									$p_score,
									$p_strand,
									$p_foldchange,
									$p_pvalue,
									$p_qvalue,
									$p_summit,
								);
								$p_summit = $p_summit || 'NA';

								# CHR PEAK_START PEAK_END PEAK_ID PEAK_SUMMIT READ_COUNT
								if( $read_count ){
									push( @p_data, $read_count );
									print OUT join( "\t", @p_data ), "\n";
								}

								# Last peak considered if there is no more reads in the BAM file
								last if eof BAM;

								# Done with this peak, go to the next
								next;
							}
						}
					}
					else{
						$state = 1;
					}
				}
				until( $state == 1 );
			}
			close BAM;
			close PEAK;
			close OUT;

			# Rename the modified file
			if( -s $chrCountFile ){
				`mv $chrCountFile $chrPeakFile`;
			}
			else{
				print STDERR "    Peak file for chromosome $chr not generated!\n";
				`rm -f $chrCountFile $chrPeakFile 2> /dev/null`;
			}
		}
		$pm->finish;
	}
	$pm->wait_all_children;

	# Count number of peaks in generated files
	my $chrCounts;
	for my $chr ( @$chroms ){
		if( $peakFiles->{$chr} ){
			if( -s $peakFiles->{$chr} ){
				my $chrPeakFile = $peakFiles->{$chr};
				my $rCount      = `cat $chrPeakFile | wc -l`; chomp $rCount;

				if( $rCount ){
					print $PLOG  "    Number of counted peaks in $chr = $rCount\n";
					print STDERR "    Number of counted peaks in $chr = $rCount\n";
					$chrCounts++;
				}
				else{
					print $PLOG  "    No counted peaks in $chr\n";
					print STDERR "    No counted peaks in $chr\n";
				}
			}
		}
	}

	if( !$chrCounts ){
		print $PLOG  "    Failed!\n";
		print STDERR "    Failed!\n";
		return 0;
	}

	# Concatenate and sort BED files
	`cut -f1-11 $outDir/chr*_$peakBase.bed | sort -Vk1,1 -k2,2g > $peakFile`;

	# Remove spurious peaks (>= 300 bp in width AND >= 200 RPKM)
	my $totalCount = `cut -f11 $peakFile | paste -sd+ | bc`; chomp $totalCount;

	open( IN, $peakFile ) or
		die "ERROR: Could not open file $peakFile\n";
	my $tmpFile = "$peakFile.tmp";
	open( OUT, ">$tmpFile" ) or
		die "ERROR: Could not open file $tmpFile.tmp\n";

	while( my $line = <IN> ){
		chomp $line;
		my @split = split( "\t", $line );
		my $start = $split[1];
		my $end   = $split[2];
		my $reads = $split[10];
		my $width = ( $end - $start ) / 1000;
		my $rpkm  = sprintf( "%.4f", ( $reads / $width ) * ( 1000000 / $totalCount ) );

		my @output = (
			$line,
			$width * 1000,
			$rpkm,
		);
		print OUT join( "\t", @output ), "\n";
	}
	close IN;
	close OUT;
	`mv -f $tmpFile $peakFile`;

	# Report on the total number of reads in all peaks
	print $PLOG  "    Total number of reads in peaks = $totalCount\n";
	print STDERR "    Total number of reads in peaks = $totalCount\n";

	my $time1   = time;
	my $elapsed = sprintf( "%.2f", ( $time1 - $time0 ) / 60 );
	print $PLOG  "  Time elapsed: $elapsed min\n";
	print STDERR "  Time elapsed: $elapsed min\n";

	return 1;
}

1;
